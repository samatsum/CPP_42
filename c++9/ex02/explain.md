初期配列
入力: [7, 3, 10, 1, 5, 8, 2, 9, 4, 6, 0]
ステップ1: order=1での処理
1-1. ペアワイズ比較
ペアを作成して比較:
[7] vs [3]  → 3 < 7 なので [3, 7] に並べ替え
[10] vs [1] → 1 < 10 なので [1, 10]
[5] vs [8]  → 5 < 8 なので [5, 8]
[2] vs [9]  → 2 < 9 なので [2, 9]
[4] vs [6]  → 4 < 6 なので [4, 6]
[0] ← 奇数個なのでペアなし

結果: [3, 7, 1, 10, 5, 8, 2, 9, 4, 6, 0]
1-2. 再帰呼び出し（order=2へ）
ステップ2: order=2での処理
2-1. 現在の配列を2要素グループとして見る
配列: [3, 7, 1, 10, 5, 8, 2, 9, 4, 6, 0]
グループ: [3,7] [1,10] [5,8] [2,9] [4,6] 余り[0]
unit_size = 11 / 2 = 5（5つのグループ）
2-2. グループのペアワイズ比較
[3,7] vs [1,10]  → 7 vs 10で比較 → 7 < 10 なのでそのまま
[5,8] vs [2,9]   → 8 vs 9で比較 → 8 < 9 なのでそのまま
[4,6] ← 奇数個のグループなのでペアなし

結果: [3, 7, 1, 10, 5, 8, 2, 9, 4, 6, 0]（変化なし）
2-3. 再帰呼び出し（order=4へ）
ステップ3: order=4での処理
3-1. 現在の配列を4要素グループとして見る
unit_size = 11 / 4 = 2（2つのグループ）
グループ: [3,7,1,10] [5,8,2,9] 余り[4,6,0]
3-2. グループのペアワイズ比較
[3,7,1,10] vs [5,8,2,9] → 10 vs 9で比較 → 10 > 9 なのでスワップ
結果: [5, 8, 2, 9, 3, 7, 1, 10, 4, 6, 0]
3-3. 再帰呼び出し（order=8へ）
ステップ4: order=8での処理
unit_size = 11 / 8 = 1（ペアを作れない）
→ ベースケースに到達、再帰から戻る
ステップ5: order=4での挿入フェーズ
5-1. チェーンの生成
現在: [5, 8, 2, 9, 3, 7, 1, 10, 4, 6, 0]
      [-グループA-] [-グループB-] [  余り ]

main_chain = [9, 10]  // 各グループの最後（代表値）
pend_chain = []       // 今回は空
odd_element = なし
leftover = [4, 6, 0]  // 余り
5-2. 元の配列の再構築
main_chain = [9, 10]の順序で、グループ全体を並べる：
9 → グループ[5,8,2,9]
10 → グループ[3,7,1,10]

結果: [5, 8, 2, 9, 3, 7, 1, 10, 4, 6, 0]
ステップ6: order=2での挿入フェーズ
6-1. チェーンの生成
現在: [5, 8, 2, 9, 3, 7, 1, 10, 4, 6, 0]
     [ペア1][ペア2][ペア3][ペア4][ペア5] 余り

main_chain = [8, 9, 10]  // a1=8, b1=9, b2=10
pend_chain = [7, 6]      // a2=7, a3=6
odd_element = なし
leftover = [0]
6-2. pend_chainの挿入（Jacobsthal順）
初期: main_chain = [8, 9, 10]

1. pend_chain[0]=7を挿入:
   二分探索: 7は8より小さい → 先頭に挿入
   main_chain = [7, 8, 9, 10]

2. pend_chain[1]=6を挿入:
   二分探索: 6は7より小さい → 先頭に挿入
   main_chain = [6, 7, 8, 9, 10]
6-3. 元の配列の再構築
main_chainの順序でグループを復元:
6 → [4,6]
7 → [3,7]
8 → [5,8]
9 → [2,9]
10 → [1,10]

結果: [4, 6, 3, 7, 5, 8, 2, 9, 1, 10, 0]
ステップ7: order=1での挿入フェーズ（最終）
7-1. チェーンの生成
main_chain = [6, 7, 9, 10]
pend_chain = [4, 3, 5, 8, 2, 1]
odd_element = 0
7-2. Jacobsthal順での挿入
順序: b3=5, b2=3, b5=2, b4=8, b6=1の順で挿入
（実際には pend_chain[2], [1], [4], [3], [5], [0]の順）

最終的に全要素が正しい位置に挿入される
最終結果
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]